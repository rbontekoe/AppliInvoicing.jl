var documenterSearchIndex = {"docs":
[{"location":"chapter1/#.-Domain-structure-and-functions-1","page":"1 - Domain","title":"2. Domain structure and functions","text":"","category":"section"},{"location":"chapter1/#Domain-structure-1","page":"1 - Domain","title":"Domain structure","text":"","category":"section"},{"location":"chapter1/#","page":"1 - Domain","title":"1 - Domain","text":"The function subtypetree is from the book Design Patterns and Best Practices with Julia","category":"page"},{"location":"chapter1/#","page":"1 - Domain","title":"1 - Domain","text":"Branches are abstract data types, and the leaves are concrete data types.","category":"page"},{"location":"chapter1/#","page":"1 - Domain","title":"1 - Domain","text":"julia> subtypes(Invoice)\n2-element Array{Any,1}:\n PaidInvoice  \n UnpaidInvoice\n\njulia> subtypetree(Domain)\nDomain\n    Invoice\n        PaidInvoice\n        UnpaidInvoice\n    Payment\n        BankStatement\n    Structure\n        BodyItem\n            OpentrainingItem\n        Header\n        MetaInvoice\n\njulia> fieldnames(PaidInvoice)\n(:id, :meta, :header, :body, :stm)\n\njulia> fieldnames(UnpaidInvoice)\n(:id, :meta, :header, :body)\n\njulia> fieldnames(BankStatement)\n(:date, :descr, :iban, :amount)\n\njulia> fieldnames(OpentrainingItem)\n(:name_training, :date, :price_per_student, :students, :vat_perc)\n\njulia> fieldnames(Header)\n(:invoice_nbr, :name, :address, :zip, :city, :country, :order_ref, :name_contact, :email_contact)\n\njulia> fieldnames(MetaInvoice)\n(:order_id, :training_id, :date, :currency, :currency_ratio)","category":"page"},{"location":"chapter1/#Getter-functions-for-Invoice-1","page":"1 - Domain","title":"Getter functions for Invoice","text":"","category":"section"},{"location":"chapter1/#id-1","page":"1 - Domain","title":"id","text":"","category":"section"},{"location":"chapter1/#","page":"1 - Domain","title":"1 - Domain","text":"id","category":"page"},{"location":"chapter1/#id","page":"1 - Domain","title":"id","text":"id(i::Invoice)\n\nReturns the id of an invoice.\n\n\n\n\n\n","category":"function"},{"location":"chapter1/#meta-1","page":"1 - Domain","title":"meta","text":"","category":"section"},{"location":"chapter1/#","page":"1 - Domain","title":"1 - Domain","text":"meta","category":"page"},{"location":"chapter1/#meta","page":"1 - Domain","title":"meta","text":"meta(i::Invoice)\n\nReturns the meta data from an invoice.\n\n\n\n\n\n","category":"function"},{"location":"chapter1/#header-1","page":"1 - Domain","title":"header","text":"","category":"section"},{"location":"chapter1/#","page":"1 - Domain","title":"1 - Domain","text":"header","category":"page"},{"location":"chapter1/#header","page":"1 - Domain","title":"header","text":"header(i::Invoice)\n\nReturns the meta data from an invoice.\n\n\n\n\n\n","category":"function"},{"location":"chapter1/#body-1","page":"1 - Domain","title":"body","text":"","category":"section"},{"location":"chapter1/#","page":"1 - Domain","title":"1 - Domain","text":"body","category":"page"},{"location":"chapter1/#body","page":"1 - Domain","title":"body","text":"body(i::Invoice)\n\nReturns the meta data from an invoice.\n\n\n\n\n\n","category":"function"},{"location":"chapter1/#stm-1","page":"1 - Domain","title":"stm","text":"","category":"section"},{"location":"chapter1/#","page":"1 - Domain","title":"1 - Domain","text":"stm","category":"page"},{"location":"chapter1/#stm","page":"1 - Domain","title":"stm","text":"stm(i::PaidInvoice)\n\nReturns the Bankstatement of a paid invoice.\n\n\n\n\n\n","category":"function"},{"location":"chapter1/#Example-1","page":"1 - Domain","title":"Example","text":"","category":"section"},{"location":"chapter1/#","page":"1 - Domain","title":"1 - Domain","text":"julia> include(\"./src/infrastructure/infrastructure.jl\"); # link to the model\n\njulia> const PATH_DB_TEST = \"./test_invoicing.sqlite\";\n\njulia> const PATH_CSV = \"./bank.csv\";\n\njulia> orders = AppliSales.process(); # get the orders\n\njulia> invnbr = 1000; # set starting invoice number\n\njulia> invoices = [create(order, \"A\" * string(global invnbr += 1)) for order in orders]; # create the invoices\n\njulia> journal_entries_1 = process(PATH_DB_TEST, orders); # # process the orders\n\njulia> stms = read_bank_statements(PATH_CSV); # retrieve the bank statemnets\n\njulia> unpaid_invoices = retrieve_unpaid_invoices(PATH_DB_TEST); # retrieve the unpaid invoices\n\njulia> id(unpaid_invoices[2]) # we will receive a payment for invoice A1002 in a later step\n\"A1002\"\n\njulia> header(unpaid_invoices[2])\nHeader(\"A1002\", \"Duck City Chronicals\", \"1185 Seven Seas Dr\", \"FL 32830\", \"Lake Buena Vista\", \"USA\", \"DD-001\", \"Mickey Mouse\", \"mickey@duckcity.com\")\n\njulia> body(unpaid_invoices[2])\nOpentrainingItem(\"Learn Smiling\", 2019-08-30T00:00:00, 1000.0, [\"Mini Mouse\", \"Goofy\"], 0.21)\n\njulia> stm(unpaid_invoices[2]) # unpaid invoice doesn't have a field stm\nERROR: MethodError: no method matching stm(::UnpaidInvoice)\nClosest candidates are:\n  stm(::PaidInvoice) at /home/rob/julia-projects/tc/AppliInvoicing/src/domain/domain.jl:75\n\njulia> journal_entries_2 = process(PATH_DB_TEST, unpaid_invoices, stms); # process the bank statements\n\njulia> paid_invoices = retrieve_paid_invoices(PATH_DB_TEST); # retrieve the paid invoices\n\njulia> id(paid_invoices[1]) # one of the paid invoices (see the step earlier retrieving the unpaid invoices)\n\"A1002\"\n\njulia> header(paid_invoices[1])\nHeader(\"A1002\", \"Duck City Chronicals\", \"1185 Seven Seas Dr\", \"FL 32830\", \"Lake Buena Vista\", \"USA\", \"DD-001\", \"Mickey Mouse\", \"mickey@duckcity.com\")\n\njulia> body(paid_invoices[1])\nOpentrainingItem(\"Learn Smiling\", 2019-08-30T00:00:00, 1000.0, [\"Mini Mouse\", \"Goofy\"], 0.21)\n\njulia> stm(paid_invoices[1])\nBankStatement(2020-01-15, \"Duck City Chronicals Invoice A1002\", \"NL93INGB\", 2420.0)\n\njulia> cmd = `rm $(PATH_DB_TEST)`; # the Linux command to remove the database\n\njulia> run(cmd); # execute the command","category":"page"},{"location":"chapter2/#.-API-1","page":"2 - API","title":"1. API","text":"","category":"section"},{"location":"chapter2/#create-1","page":"2 - API","title":"create","text":"","category":"section"},{"location":"chapter2/#","page":"2 - API","title":"2 - API","text":"create","category":"page"},{"location":"chapter2/#create","page":"2 - API","title":"create","text":"create(::AppliSales.Order, invoice_id::String)::UnpaidInvoice\n\ncreate(::UnpaidInvoice, ::AppliGeneralLedger.BankStatement)::PaidInvoice\n\nCreate an UnpaidInvoice from an AppliSales.Order.\nCreate a PaidInvoice from an UnpaidInvoice and a BankStatement.\n\n@see also conv2entry\n\nExample - create an UnpaidInvoice\n\njulia> using AppliInvoicing\n\njulia> using AppliSales\n\njulia> orders = AppliSales.process()\n\njulia> invnbr = 1000\n\njulia> invoices = [create(order, \"A\" * string(global invnbr += 1)) for order in orders]\n\njulia> cmd = `rm test_invoicing.sqlite`\n\njulia> run(cmd)\n\nExample - create a PaidInvoice\n\njulia> using Dates\n\njulia> using AppliInvoicing\n\njulia> using AppliSales\n\njulia> orders = AppliSales.process()\n\njulia> invnbr = 1000\n\njulia> unpaid_invoices = [create(order, \"A\" * string(global invnbr += 1)) for order in orders]\n\njulia> import AppliInvoicing.BankStatement\n\njulia> stms = [BankStatement(Date(2020-01-15), \"Duck City Chronicals Invoice A1002\", \"NL93INGB\", 2420.0)]\n\njulia> potential_paid_invoices = []\n\njulia> for unpaid_invoice in unpaid_invoices\n    \t\tfor stm in stms # get potential paid invoices\n        \t\tif occursin(unpaid_invoice.id, stm.descr) # description contains invoice number\n                \tpush!(potential_paid_invoices, create(unpaid_invoice, stm))\n        \t\tend\n        \tend\n        end\n\njulia> potential_paid_invoices\n\njulia> cmd = `rm test_invoicing.sqlite`\n\njulia> run(cmd)\n\n\n\n\n\n","category":"function"},{"location":"chapter2/#conv2entry-1","page":"2 - API","title":"conv2entry","text":"","category":"section"},{"location":"chapter2/#","page":"2 - API","title":"2 - API","text":"conv2entry","category":"page"},{"location":"chapter2/#conv2entry","page":"2 - API","title":"conv2entry","text":"conv2entry(::UnpaidInvoice, from::Int, to::Int)\n\nconv2entry(::PaidInvoice, from::Int, to::Int)\n\nConverts an invoice into AppliGeneralLedger.JournalEntry's.\n\n@see also create\n\njulia> include(\"./src/api/api.jl\");\n\njulia using Dates\n\njulia> using AppliSales\n\njulia> using AppliGeneralLedger\n\njulia> orders = AppliSales.process()\n\njulia> invnbr = 1000\n\njulia> unpaid_invoice = create(orders[1], \"A\" * string(invnbr += 1))\n\njulia> n = 100\n\njulia> journal_entries = conv2entry(unpaid_invoice, 1300, 8000)\n\njulia> cmd = `rm test_invoicing.sqlite`\n\njulia> run(cmd)\n\n\n\n\n\n","category":"function"},{"location":"chapter4/#Example-1","page":"4 - Examples","title":"Example","text":"","category":"section"},{"location":"chapter4/#Example-user-1","page":"4 - Examples","title":"Example -  user","text":"","category":"section"},{"location":"chapter4/#","page":"4 - Examples","title":"4 - Examples","text":"julia> using AppliSales\n\njulia> using AppliInvoicing\n\njulia> using AppliGeneralLedger\n\njulia> using DataFrames\n\njulia> using CSV\n\njulia> using SQLite\n\njulia> const PATH_DB = \"./test_invoicing.sqlite\"\n\"./test_invoicing.sqlite\"\n\njulia> const PATH_CSV = \"./bank.csv\"\n\"./bank.csv\"\n\njulia> # get orders\n       orders = AppliSales.process()\n3-element Array{AppliSales.Order,1}:\n AppliSales.Order(\"2438091263718968922\", AppliSales.Organization(\"3427371109961104901\", \"Scrooge Investment Bank\", \"1180 Seven Seas Dr\", \"FL 32830\", \"Lake Buena Vista\", \"USA\"), AppliSales.Training(\"LS\", 2019-08-30T00:00:00, 2, \"Learn Smiling\", 1000.0), \"PO-456\", \"Scrooge McDuck\", \"scrooge@duckcity.com\", [\"Scrooge McDuck\"])\n AppliSales.Order(\"1138078377637347262\", AppliSales.Organization(\"3868942126239046229\", \"Duck City Chronicals\", \"1185 Seven Seas Dr\", \"FL 32830\", \"Lake Buena Vista\", \"USA\"), AppliSales.Training(\"LS\", 2019-08-30T00:00:00, 2, \"Learn Smiling\", 1000.0), \"DD-001\", \"Mickey Mouse\", \"mickey@duckcity.com\", [\"Mini Mouse\", \"Goofy\"])\n AppliSales.Order(\"12370498358369136371\", AppliSales.Organization(\"2768094194732922249\", \"Donalds Hardware Store\", \"1190 Seven Seas Dr\", \"FL 32830\", \"Lake Buena Vista\", \"USA\"), AppliSales.Training(\"LS\", 2019-08-30T00:00:00, 2, \"Learn Smiling\", 1000.0), \"\", \"Donald Duck\", \"donald@duckcity.com\", [\"Daisy Duck\"])              \n\njulia> # create journal statments for general ledger\n       journal_entries_1 = AppliInvoicing.process(PATH_DB, orders)\n3-element Array{AppliGeneralLedger.JournalEntry,1}:\n AppliGeneralLedger.JournalEntry(\"2020-03-04-1\", 3, 2020-03-04T11:15:04.628, \"Scrooge Investment Bank\", \"A1001\", 1300, 8000, 1000.0, 0.0, 210.0, \"Learn Smiling\")\n AppliGeneralLedger.JournalEntry(\"2020-03-04-2\", 3, 2020-03-04T11:15:04.628, \"Duck City Chronicals\", \"A1002\", 1300, 8000, 2000.0, 0.0, 420.0, \"Learn Smiling\")   \n AppliGeneralLedger.JournalEntry(\"2020-03-04-3\", 3, 2020-03-04T11:15:04.628, \"Donalds Hardware Store\", \"A1003\", 1300, 8000, 1000.0, 0.0, 210.0, \"Learn Smiling\")\n\njulia> # get Bank statemnets and unpaid invoices\n       stms = AppliInvoicing.read_bank_statements(PATH_CSV)\n2-element Array{AppliInvoicing.BankStatement,1}:\n AppliInvoicing.BankStatement(2020-01-15, \"Duck City Chronicals Invoice A1002\", \"NL93INGB\", 2420.0)\n AppliInvoicing.BankStatement(2020-01-15, \"Donalds Hardware Store Bill A1003\", \"NL39INGB\", 1210.0)\n\njulia> # retrieve unpaid invoices\n       unpaid_invoices = retrieve_unpaid_invoices(PATH_DB)\n3-element Array{AppliInvoicing.UnpaidInvoice,1}:\n AppliInvoicing.UnpaidInvoice(\"A1001\", AppliInvoicing.MetaInvoice(\"2438091263718968922\", \"LS\", 2020-03-04T11:15:02.978, \"€\", 1.0), AppliInvoicing.Header(\"A1001\", \"Scrooge Investment Bank\", \"1180 Seven Seas Dr\", \"FL 32830\", \"Lake Buena Vista\", \"USA\", \"PO-456\", \"Scrooge McDuck\", \"scrooge@duckcity.com\"), AppliInvoicing.OpentrainingItem(\"Learn Smiling\", 2019-08-30T00:00:00, 1000.0, [\"Scrooge McDuck\"], 0.21))\n AppliInvoicing.UnpaidInvoice(\"A1002\", AppliInvoicing.MetaInvoice(\"1138078377637347262\", \"LS\", 2020-03-04T11:15:02.978, \"€\", 1.0), AppliInvoicing.Header(\"A1002\", \"Duck City Chronicals\", \"1185 Seven Seas Dr\", \"FL 32830\", \"Lake Buena Vista\", \"USA\", \"DD-001\", \"Mickey Mouse\", \"mickey@duckcity.com\"), AppliInvoicing.OpentrainingItem(\"Learn Smiling\", 2019-08-30T00:00:00, 1000.0, [\"Mini Mouse\", \"Goofy\"], 0.21))\n AppliInvoicing.UnpaidInvoice(\"A1003\", AppliInvoicing.MetaInvoice(\"12370498358369136371\", \"LS\", 2020-03-04T11:15:02.978, \"€\", 1.0), AppliInvoicing.Header(\"A1003\", \"Donalds Hardware Store\", \"1190 Seven Seas Dr\", \"FL 32830\", \"Lake Buena Vista\", \"USA\", \"\", \"Donald Duck\", \"donald@duckcity.com\"), AppliInvoicing.OpentrainingItem(\"Learn Smiling\", 2019-08-30T00:00:00, 1000.0, [\"Daisy Duck\"], 0.21))              \n\njulia> # process unpaid invoices and bank statements\n       journal_entries_2 = AppliInvoicing.process(PATH_DB, unpaid_invoices, stms)\n2-element Array{AppliGeneralLedger.JournalEntry,1}:\n AppliGeneralLedger.JournalEntry(\"2020-03-04-4\", 3, 2020-03-04T11:15:12.968, \"Duck City Chronicals\", \"A1002\", 1150, 1300, 2420.0, 0.0, 0.0, \"Learn Smiling\")  \n AppliGeneralLedger.JournalEntry(\"2020-03-04-5\", 3, 2020-03-04T11:15:12.968, \"Donalds Hardware Store\", \"A1003\", 1150, 1300, 1210.0, 0.0, 0.0, \"Learn Smiling\")\n\njulia> # =============================\n\n       # process journal entries\n       const PATH_DB_LEDGER = \"./test_ledger.txt\"\n\"./test_ledger.txt\"\n\njulia> const PATH_DB_JOURNAL = \"./test_journal.txt\"\n\"./test_journal.txt\"\n\njulia> # process the journal statements for the uppaid invoices\n       AppliGeneralLedger.process(PATH_DB_JOURNAL, PATH_DB_LEDGER, journal_entries_1)\n\njulia> # process journal journal statements for the paid invoices\n       AppliGeneralLedger.process(PATH_DB_JOURNAL, PATH_DB_LEDGER, journal_entries_2)\n\njulia> # read all general ledger accounts\n       r = AppliGeneralLedger.read_from_file(PATH_DB_LEDGER)\n13-element Array{Any,1}:\n AppliGeneralLedger.Record(\"2020-03-04-1\", 1300, 2020-03-04T11:15:04.628, \"Scrooge Investment Bank\", \"A1001\", 1210.0, 0.0, \"Learn Smiling\")\n AppliGeneralLedger.Record(\"2020-03-04-1\", 8000, 2020-03-04T11:15:04.628, \"Scrooge Investment Bank\", \"A1001\", 0.0, 1000.0, \"Learn Smiling\")\n AppliGeneralLedger.Record(\"2020-03-04-1\", 4000, 2020-03-04T11:15:04.628, \"Scrooge Investment Bank\", \"A1001\", 0.0, 210.0, \"Learn Smiling\")\n AppliGeneralLedger.Record(\"2020-03-04-2\", 1300, 2020-03-04T11:15:04.628, \"Duck City Chronicals\", \"A1002\", 2420.0, 0.0, \"Learn Smiling\")   \n AppliGeneralLedger.Record(\"2020-03-04-2\", 8000, 2020-03-04T11:15:04.628, \"Duck City Chronicals\", \"A1002\", 0.0, 2000.0, \"Learn Smiling\")   \n ⋮                                                                                                                                         \n AppliGeneralLedger.Record(\"2020-03-04-4\", 1150, 2020-03-04T11:15:12.968, \"Duck City Chronicals\", \"A1002\", 2420.0, 0.0, \"Learn Smiling\")   \n AppliGeneralLedger.Record(\"2020-03-04-4\", 1300, 2020-03-04T11:15:12.968, \"Duck City Chronicals\", \"A1002\", 0.0, 2420.0, \"Learn Smiling\")   \n AppliGeneralLedger.Record(\"2020-03-04-5\", 1150, 2020-03-04T11:15:12.968, \"Donalds Hardware Store\", \"A1003\", 1210.0, 0.0, \"Learn Smiling\")\n AppliGeneralLedger.Record(\"2020-03-04-5\", 1300, 2020-03-04T11:15:12.968, \"Donalds Hardware Store\", \"A1003\", 0.0, 1210.0, \"Learn Smiling\")\n\njulia> df = DataFrame(r)\n13×8 DataFrame. Omitted printing of 1 columns\n│ Row │ id           │ accountid │ date                    │ customerid              │ invoice_nbr │ debit   │ credit  │\n│     │ String       │ Int64     │ Dates.DateTime          │ String                  │ String      │ Float64 │ Float64 │\n├─────┼──────────────┼───────────┼─────────────────────────┼─────────────────────────┼─────────────┼─────────┼─────────┤\n│ 1   │ 2020-03-04-1 │ 1300      │ 2020-03-04T11:15:04.628 │ Scrooge Investment Bank │ A1001       │ 1210.0  │ 0.0     │\n│ 2   │ 2020-03-04-1 │ 8000      │ 2020-03-04T11:15:04.628 │ Scrooge Investment Bank │ A1001       │ 0.0     │ 1000.0  │\n⋮\n│ 11  │ 2020-03-04-4 │ 1300      │ 2020-03-04T11:15:12.968 │ Duck City Chronicals    │ A1002       │ 0.0     │ 2420.0  │\n│ 12  │ 2020-03-04-5 │ 1150      │ 2020-03-04T11:15:12.968 │ Donalds Hardware Store  │ A1003       │ 1210.0  │ 0.0     │\n│ 13  │ 2020-03-04-5 │ 1300      │ 2020-03-04T11:15:12.968 │ Donalds Hardware Store  │ A1003       │ 0.0     │ 1210.0  │\n\njulia> println(df)\n13×8 DataFrame\n│ Row │ id           │ accountid │ date                    │ customerid              │ invoice_nbr │ debit   │ credit  │ descr         │\n│     │ String       │ Int64     │ Dates.DateTime          │ String                  │ String      │ Float64 │ Float64 │ String        │\n├─────┼──────────────┼───────────┼─────────────────────────┼─────────────────────────┼─────────────┼─────────┼─────────┼───────────────┤\n│ 1   │ 2020-03-04-1 │ 1300      │ 2020-03-04T11:15:04.628 │ Scrooge Investment Bank │ A1001       │ 1210.0  │ 0.0     │ Learn Smiling │\n│ 2   │ 2020-03-04-1 │ 8000      │ 2020-03-04T11:15:04.628 │ Scrooge Investment Bank │ A1001       │ 0.0     │ 1000.0  │ Learn Smiling │\n│ 3   │ 2020-03-04-1 │ 4000      │ 2020-03-04T11:15:04.628 │ Scrooge Investment Bank │ A1001       │ 0.0     │ 210.0   │ Learn Smiling │\n│ 4   │ 2020-03-04-2 │ 1300      │ 2020-03-04T11:15:04.628 │ Duck City Chronicals    │ A1002       │ 2420.0  │ 0.0     │ Learn Smiling │\n│ 5   │ 2020-03-04-2 │ 8000      │ 2020-03-04T11:15:04.628 │ Duck City Chronicals    │ A1002       │ 0.0     │ 2000.0  │ Learn Smiling │\n│ 6   │ 2020-03-04-2 │ 4000      │ 2020-03-04T11:15:04.628 │ Duck City Chronicals    │ A1002       │ 0.0     │ 420.0   │ Learn Smiling │\n│ 7   │ 2020-03-04-3 │ 1300      │ 2020-03-04T11:15:04.628 │ Donalds Hardware Store  │ A1003       │ 1210.0  │ 0.0     │ Learn Smiling │\n│ 8   │ 2020-03-04-3 │ 8000      │ 2020-03-04T11:15:04.628 │ Donalds Hardware Store  │ A1003       │ 0.0     │ 1000.0  │ Learn Smiling │\n│ 9   │ 2020-03-04-3 │ 4000      │ 2020-03-04T11:15:04.628 │ Donalds Hardware Store  │ A1003       │ 0.0     │ 210.0   │ Learn Smiling │\n│ 10  │ 2020-03-04-4 │ 1150      │ 2020-03-04T11:15:12.968 │ Duck City Chronicals    │ A1002       │ 2420.0  │ 0.0     │ Learn Smiling │\n│ 11  │ 2020-03-04-4 │ 1300      │ 2020-03-04T11:15:12.968 │ Duck City Chronicals    │ A1002       │ 0.0     │ 2420.0  │ Learn Smiling │\n│ 12  │ 2020-03-04-5 │ 1150      │ 2020-03-04T11:15:12.968 │ Donalds Hardware Store  │ A1003       │ 1210.0  │ 0.0     │ Learn Smiling │\n│ 13  │ 2020-03-04-5 │ 1300      │ 2020-03-04T11:15:12.968 │ Donalds Hardware Store  │ A1003       │ 0.0     │ 1210.0  │ Learn Smiling │\n\njulia> # select only the journal statements for account 1300 (accounts receivable)\n       df2 = df[df.accountid .== 1300, :]\n5×8 DataFrame. Omitted printing of 1 columns\n│ Row │ id           │ accountid │ date                    │ customerid              │ invoice_nbr │ debit   │ credit  │\n│     │ String       │ Int64     │ Dates.DateTime          │ String                  │ String      │ Float64 │ Float64 │\n├─────┼──────────────┼───────────┼─────────────────────────┼─────────────────────────┼─────────────┼─────────┼─────────┤\n│ 1   │ 2020-03-04-1 │ 1300      │ 2020-03-04T11:15:04.628 │ Scrooge Investment Bank │ A1001       │ 1210.0  │ 0.0     │\n│ 2   │ 2020-03-04-2 │ 1300      │ 2020-03-04T11:15:04.628 │ Duck City Chronicals    │ A1002       │ 2420.0  │ 0.0     │\n│ 3   │ 2020-03-04-3 │ 1300      │ 2020-03-04T11:15:04.628 │ Donalds Hardware Store  │ A1003       │ 1210.0  │ 0.0     │\n│ 4   │ 2020-03-04-4 │ 1300      │ 2020-03-04T11:15:12.968 │ Duck City Chronicals    │ A1002       │ 0.0     │ 2420.0  │\n│ 5   │ 2020-03-04-5 │ 1300      │ 2020-03-04T11:15:12.968 │ Donalds Hardware Store  │ A1003       │ 0.0     │ 1210.0  │\n\njulia> # calculate the balance for accounts receivable\n       account_receivable = sum(df2.debit - df2.credit)\n1210.0\n\njulia> @info(\"Balance of accounts receivable is $(account_receivable). Should be 1210\")\n[ Info: Balance of accounts receivable is 1210.0. Should be 1210\n\njulia> println(\"Status accounts receivable: € $account_receivable\") # should be € 1210.0\nStatus accounts receivable: € 1210.0\n\njulia> # select the statements for account 8000 (sales)\n       df2 = df[df.accountid .== 8000, :]\n3×8 DataFrame. Omitted printing of 1 columns\n│ Row │ id           │ accountid │ date                    │ customerid              │ invoice_nbr │ debit   │ credit  │\n│     │ String       │ Int64     │ Dates.DateTime          │ String                  │ String      │ Float64 │ Float64 │\n├─────┼──────────────┼───────────┼─────────────────────────┼─────────────────────────┼─────────────┼─────────┼─────────┤\n│ 1   │ 2020-03-04-1 │ 8000      │ 2020-03-04T11:15:04.628 │ Scrooge Investment Bank │ A1001       │ 0.0     │ 1000.0  │\n│ 2   │ 2020-03-04-2 │ 8000      │ 2020-03-04T11:15:04.628 │ Duck City Chronicals    │ A1002       │ 0.0     │ 2000.0  │\n│ 3   │ 2020-03-04-3 │ 8000      │ 2020-03-04T11:15:04.628 │ Donalds Hardware Store  │ A1003       │ 0.0     │ 1000.0  │\n\njulia> sales = sum(df2.credit - df2.debit) # should return € 4000.0\n4000.0\n\njulia> @info(\"Sales is $(sales). Should be 4000.\")\n[ Info: Sales is 4000.0. Should be 4000.\n\njulia> println(\"Sales: € $sales\")\nSales: € 4000.0\n\njulia> # cleanup\n       stm = `rm test_invoicing.sqlite test_ledger.txt test_journal.txt`\n`rm test_invoicing.sqlite test_ledger.txt test_journal.txt`\n\njulia> run(stm)\nProcess(`rm test_invoicing.sqlite test_ledger.txt test_journal.txt`, ProcessExited(0))","category":"page"},{"location":"chapter3/#.-Infrastructure-functions-1","page":"3 - Infrastructure","title":"2. Infrastructure functions","text":"","category":"section"},{"location":"chapter3/#process-1","page":"3 - Infrastructure","title":"process","text":"","category":"section"},{"location":"chapter3/#","page":"3 - Infrastructure","title":"3 - Infrastructure","text":"process","category":"page"},{"location":"chapter3/#process","page":"3 - Infrastructure","title":"process","text":"process(path::String, ::Array{AppliSales.Order, 1})\n\nprocess(path::String, ::Array{UnpaidInvoice, 1}, ::Array{AppliGeneralLedger.BankStatement, 1})\n\nCreates UnpaidInvoice's from AppliSale.Order's, archive them, and creates AppliGeneralLedger.Entry's for the general ledger.\nCreates PaidInvoices's from UnpaidInvoices by using AppliGeneralLedger.BankStatement's, and creates AppliGeneralLedger.Entry's for the general ledger.\n\nExample\n\njulia> using AppliSales\n\njulia> using AppliGeneralLedger\n\njulia> using AppliInvoicing\n\njulia> const PATH_DB = \"./test_invoicing.sqlite\"\n\njulia> const PATH_CSV = \"./bank.csv\"\n\njulia> orders = AppliSales.process()\n\njulia> journal_entries_1 = AppliInvoicing.process(PATH_DB, orders)\n\njulia> stms = AppliInvoicing.read_bank_statements(PATH_CSV)\n\njulia> unpaid_invoices = retrieve_unpaid_invoices(PATH_DB)\n\njulia> journal_entries_2 = AppliInvoicing.process(PATH_DB, unpaid_invoices, stms)\n\njulia> cmd = `rm test_invoicing.sqlite`\n\njulia> run(cmd)\n\n\n\n\n\n","category":"function"},{"location":"chapter3/#read_bank_statements-1","page":"3 - Infrastructure","title":"read_bank_statements","text":"","category":"section"},{"location":"chapter3/#","page":"3 - Infrastructure","title":"3 - Infrastructure","text":"read_bank_statements","category":"page"},{"location":"chapter3/#read_bank_statements","page":"3 - Infrastructure","title":"read_bank_statements","text":"read_bank_statements(path::String)\n\nRetrieves bank statements from a CSV-file.\n\nExample\n\njulia> const PATH_CSV = \"./bank.csv\"\n\njulia> stms = AppliInvoicing.read_bank_statements(PATH_CSV)\n\n\n\n\n\n","category":"function"},{"location":"chapter3/#retrieve_unpaid_invoices-1","page":"3 - Infrastructure","title":"retrieve_unpaid_invoices","text":"","category":"section"},{"location":"chapter3/#","page":"3 - Infrastructure","title":"3 - Infrastructure","text":"retrieve_unpaid_invoices","category":"page"},{"location":"chapter3/#retrieve_unpaid_invoices","page":"3 - Infrastructure","title":"retrieve_unpaid_invoices","text":"retrieve_unpaid_invoices(path::String)::Array{UnpaidInvoice, 1}\n\nRetrieves UnpaidInvoice's from a SQLite.jl database.\n\nExample\n\njulia> using AppliSales\n\njulia> using AppliInvoicing\n\njulia> const PATH_DB = \"./test_invoicing.sqlite\"\n\njulia> orders = AppliSales.process()\n\njulia> AppliInvoicing.process(PATH_DB, orders)\n\njulia> unpaid_invoices = retrieve_unpaid_invoices(PATH_DB)\n\njulia> cmd = `rm test_invoicing.sqlite`\n\njulia> run(cmd)\n\n\n\n\n\n","category":"function"},{"location":"chapter3/#retrieve_paid_invoices-1","page":"3 - Infrastructure","title":"retrieve_paid_invoices","text":"","category":"section"},{"location":"chapter3/#","page":"3 - Infrastructure","title":"3 - Infrastructure","text":"retrieve_paid_invoices","category":"page"},{"location":"chapter3/#retrieve_paid_invoices","page":"3 - Infrastructure","title":"retrieve_paid_invoices","text":"retrieve_paid_invoices(path::String)::Array{PaidInvoice, 1}\n\nRetrieves PaidInvoice's from a SQLite.jl database.\n\nExample\n\nTODO\n\n\n\n\n\n","category":"function"},{"location":"#","page":"Invoicing","title":"Invoicing","text":"(Image: AppliGate)","category":"page"},{"location":"#Invoicing-module-1","page":"Invoicing","title":"Invoicing module","text":"","category":"section"},{"location":"#","page":"Invoicing","title":"Invoicing","text":"In course BAWJ, you learn to create Julia modules. The software you write makes use of these modules and runs in Docker containers.","category":"page"},{"location":"#","page":"Invoicing","title":"Invoicing","text":"The AppliInvoicing module is used in the course to demonstrate the working of an invoicing application.","category":"page"}]
}
